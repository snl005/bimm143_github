---
title: "Class 12: RNASeq"
author: "Le, Sarah (A18518276)"
format: pdf
toc: true
---

## Background

Today, we will analyze some RNASeq data from Himes et al. on the effects of a common steroid on airway smooth muscle cells (ASM cells).

At starting point is the "counts" data and "metadata" that contain the count values for each gene in their different experiments (i.e. cell lines with or without the drug).

## Data import

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

Let's have a wee peak at these objects:

```{r}
head(counts)
```

```{r}
head(metadata)
```

> Q1. How many genes are in this dataset? 

```{r}
nrow(counts)
```

> Q. How many different experiments (columns in counts or rows in metadata) are there?

```{r}
ncol(counts)
```

```{r}
nrow(metadata)
```

> Q2. How many ‘control’ cell lines do we have?

```{r}
sum(metadata$dex == "control")
```

## Toy differential gene expression

To start our analysis, let's calculate the mean counts for all genes in the "control" experiments. 

1. Extract all "control" columns from the `counts` object.
2. Calculate the mean for all rows (i.e. genes) of these "contol" columns.
3-4. Do the same for "treated".
5. Compare these `control.mean` and `treated.mean` values.

```{r}
control.inds <- metadata$dex == "control"
control.counts <- counts[ ,control.inds]
```

```{r}
control.means <- rowMeans(control.counts)
head(control.means)
```
> Q3. How would you make the above code in either approach more robust? Is there a function that could help here? 

Instead of using rowSums() by 4, we can use rowMeans() function instead as it will automatically calculate the mean accross rows regardless of the amount of samples so it is more flexible if we need to add more samples. 

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)


```{r}
treated.inds <- metadata$dex == "treated"
treated.counts <- counts[, treated.inds]
```

```{r}
treated.means <- rowMeans(treated.counts)
```

Store these together for ease of book keeping as `meancounts`.

```{r}
meancounts <- data.frame(control.means, treated.means)
head(meancounts)
```

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

Make a plot of control vs treated mean values for all genes.

```{r}
plot(meancounts)
```

> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

```{r}
library(ggplot2)
ggplot(meancounts, aes(control.means, treated.means))+
  geom_point()
```

> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? 

```{r}
plot(meancounts, log="xy")
```

We often talk metrics like "log2 fold-change".

```{r}
# treated/control
log2(10/10)
```

```{r}
log2(10/20)
```

```{r}
log2(20/10)
```

```{r}
log2(40/10)
log2(10/40)
```

Let's calculate the log2 fold chain for our treated over control mean counts.

```{r}
meancounts$log2fc <-
log2(meancounts$treated.means/
  meancounts$control.means)
```

```{r}
head(meancounts)
```

Let’s filter our data to remove these genes.

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

arr.ind = TRUE will returns row or column locations. [ ,1] will keep only the row indices (genes) and then unique() will remove duplicates so we only filter each gene once. 

A common "rule of thumb" is a log2 fold chain cutoff of +2 and -2 to call genes "Up regulated" or "Down regulated". 

Number of "Up regulated" genes. 

```{r}
sum(meancounts$log2fc >= +2, na.rm= T)
```

Number of "Down regulated" genes at -2 threshold. 

```{r}
sum(meancounts$log2fc <= -2, na.rm = T)
```

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
up.ind <- mycounts$log2fc > 2
sum(up.ind)
```


> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
down.ind <- mycounts$log2fc < (-2)
sum(down.ind)
```

> Q10. Do you trust these results? Why or why not?

No because these results are only at fold-change values without testing for statistical significance (p-values) so large fold-changes can occure due to noise or by change. We need to use DESeq2 to confirm which genes are truly differentially expressed. 

## DESeq2

Let's do this analysis properly and keep our inner stats nerd happy - i.e. are the difference we see between drug and no drug significant given the replicate experiments.

```{r, message= FALSE}
library(DESeq2)
```

For DESeq analysis, we need three things.

- count values (`countData`).
- metadata telling us about the columns in `countData` (`colData`).
- design of the experiment (i.e. what do you want to compare?).

Our first function from DESeq2 will setup the input required for analysis by storing all these 3 things together.

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts, 
                              colData = metadata, 
                              design = ~dex)
```

The main function in DESeq2 that runs the analysis is called `DESeq()`.

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```

```{r}
36000*0.05
```

## Volcano Plot

This is common summary result figure from these types of experiments and plot the log2 fold-change vs the adjusted p-value.

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2), col="red")
abline(h=-log(0.04), col= "red")
```

```{r}
log(0.1)
log(0.00001)
```


## Save our results

```{r}
write.csv(res, file= "my_results.csv")
```

